
var electron = require('electron'),
	pad = require('pad'),
	Command = require('./command'),
	help = require('./help');

module.exports = Program;

function Program (name) {

	this.commands = [];
	this.argv = [];
	this.label = name;
	this.description = '';
	this.running = undefined;

}

Program.prototype.desc = function (desc) {

	this.description = desc;

	return this;

};

Program.prototype.command = function (name) {

	var command = new Command(name, this.label);
	this.commands.push(command);

	return command;

};

Program.prototype.parse = function (args) {

	args = args || process.argv;

	this.argv = electron.argv(args);

	this.matchCommand();

	return this;

};

Program.prototype.matchCommand = function () {

	var _self = this,
		running,
		runningHelp;

	this.commands.some(function (command) {

		var regex = command.generateRegex();

		// do we have a full match?
		if (_self.match(_self.argv.commands.join(' '), regex.regex)) {

			var returnObj = {
				args: _self.args(_self.argv.commands.join(' '), regex),
				modes: _self.argv.modes,
				params: _self.argv.params
			};

			if (typeof command.act === 'function') {
				running = command;
				command.act(returnObj);
				return true;
			}

		// do we have a head match on the command itself and non-value arguments and need to call help?
		} else if (_self.match(_self.argv.commands.join(' '), regex.regexHead)) {

			runningHelp = command;
			command.displayHelp();
			return true;

		}

		return false;

	});

	if (!running && !runningHelp) {

		// before running help for the entire program
		// let's match on the command and non-value arguments
		// if we find a match, we'll run help on that specific command
		// this will allow us to provide help for a particular command when not all 'required value arguments' have been provided
		this.commands.some(function (command) {

			var commandBuffer = [];

			// loop through the commands, going backwards until we find a match
			for (var i = 0; i < this.argv.commands.length; i++) {

				commandBuffer.push(this.argv.commands[i]);

				if (commandBuffer.join(' ') === [command.name,command.baseCommands()].join(' ').trim()) {

					runningHelp = command;
					command.displayHelp();
					return true;

				}

			}

			return false;

		}, this);

		if (!runningHelp) {

			// try and find a match just on command name, ignoring non-value required arguments
			this.commands.some(function (command) {

				if (this.argv.commands[0] === command.name) {

					runningHelp = command;
					this.displayHelp(command, command.name);
					return true;

				}

				return false;

			}, this);

		}

		// nothing found, run help for the entire program
		if (!runningHelp) {
			this.displayHelp();
		}

	} 

	if (running) {
		this.running = running;
	}

};

Program.prototype.match = function (command, regex) {

	return regex.test(command);

};

Program.prototype.args = function (command, regex) {

	var args = {},
		results = command.match(regex.regex);

	if (results.length > 1) {

		for (var i = 1; i < results.length; i++) {
			args[regex.keys[i-1].name] = (results[i] !== undefined) ? results[i] : regex.defaults[regex.keys[i-1].name] || undefined ;
		}

	}

	return args;

};

Program.prototype.displayHelp = function (command, consolidate) {

	var _self = this,
		lCommand = 0,
		lCommandPadding = 6;

	if (command && consolidate) {

		var commands = [];

		this.commands.forEach(function (command) {

			if (command.name === consolidate) {
				commands.push(command);
			}

		});

		// determine the command with the longest padding
		commands.forEach(function (command) {
			if (command.toString().length > lCommand) {
				lCommand = command.toString().length;
			}
		});

		help.log('');
		help.log('\tHelp for \'' + this.label + ' ' + command.name + '\'\n');

		if (commands.length > 1) {

			help.log('\tUsage');

			commands.forEach(function (command) {

				help.log('\t\t' + pad(_self.label + ' ' + command.toString(), lCommand + lCommandPadding) + ((command.description.length) ? '\t' + command.description : ''));

			});

		} else {

			help.log('\tUsage: ' + commands[0].toString());

		}

		return help.log('\n');
	}
	
	/**
	 * Output help for the entire program
	 */
	
	// determine the command with the longest padding
	this.commands.forEach(function (command) {
		if (command.toString().length > lCommand) {
			lCommand = command.toString().length;
		}
	});

	help.log('');

	help.log('\tHelp for \'' + this.label + '\'\n');

	if (this.description.length) {
		help.log('\t' + this.description + '\n');
	}

	if (this.commands.length === 1) {
		help.log('\tUsage: ' + this.label + ' ' + this.commands[0].toString());
	} else {

		help.log('\tUsage:');
		this.commands.forEach(function (command) {
			help.log('\t\t' + pad(_self.label + ' ' + command.toString(), lCommand + lCommandPadding) + ((command.description.length) ? command.description: ''));
		});

	}

	help.log('\n');

};